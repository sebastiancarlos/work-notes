#!/usr/bin/env bash

# SCRIPT_DIR is set to the directory where this script is located. If it was
# run by a symlink, it will be resolved to the directory of the target script
# (that is, the actual script directory).
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
if [[ -L "${BASH_SOURCE[0]}" ]]; then
    SCRIPT_DIR="$(readlink "${BASH_SOURCE[0]}")"
    SCRIPT_DIR="$( cd "$( dirname "${SCRIPT_DIR}" )" >/dev/null 2>&1 && pwd )"
fi

# on -h, or --help, print usage
if [[ "$#" -eq 1 && ( "$1" == "-h" || "$1" == "--help" ) ]]; then
    echo "Usage: work-notes [notes-path-prefix]"
    echo ""
    echo "Finds and opens a note file using fzf."
    echo " - Runs an fzf search scoped to the notes directory."
    echo " - If a prefix is provided, it's used as the initial fzf query."
    echo " - If the prefix matches exactly one file, it opens it directly."
    exit 0
fi

# Exit if fzf is not installed
if ! command -v fzf &> /dev/null; then
  echo "Error: fzf is not installed."
  echo "Please install fzf to use this command."
  exit 1
fi

STOW_DIR="${SCRIPT_DIR}/base"
cd "${STOW_DIR}" || { echo "Error: Notes directory not found at ${STOW_DIR}"; exit 1; }

# Get the prefix from the first argument (it can be empty)
PREFIX="$1"
NOTES_FILE=""

# Find all files, excluding dotfiles, and clean up the './' prefix from find.
ALL_FILES=$(find . -type f -not -path '*/\.*' | sed 's/^\.\///' | sort)

if [[ -z "$ALL_FILES" ]]; then
  echo "No note files found in '${STOW_DIR}'."
  echo "Create a new note first using the 'new-work-notes' command."
  exit 1
fi

NOTES_FILE=$(echo "${ALL_FILES}" | fzf --query="${PREFIX}")

# If NOTES_FILE is empty at this point (user cancelled fzf), exit.
if [[ -z "$NOTES_FILE" ]]; then
    echo "No file selected."
    exit 1
fi

# Open the selected file in the system editor.
EDITOR="${EDITOR:-vim}"
echo "Opening ${NOTES_FILE}..."
ABSOLUTE_NOTES_FILE="${STOW_DIR}/${NOTES_FILE}"
final_command="${EDITOR} ${ABSOLUTE_NOTES_FILE}"
${final_command}

# print the final command to a file, in case a wrapper script wants to add it
# to the history
echo "${final_command}" >| /tmp/work-notes-last-command.txt
